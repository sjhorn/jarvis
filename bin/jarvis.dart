import 'dart:async';
import 'dart:io';

import 'package:jarvis_dart/src/cli/config_loader.dart';
import 'package:jarvis_dart/src/cli/model_downloader.dart';
import 'package:jarvis_dart/src/cli/package_assets.dart';
import 'package:jarvis_dart/src/logging.dart';
import 'package:jarvis_dart/src/voice_assistant.dart';
import 'package:logging/logging.dart';

/// JARVIS version
const version = '1.0.5';

/// Default JARVIS system prompt.
const defaultSystemPrompt = '''
You are JARVIS, an advanced AI assistant inspired by the AI from Iron Man.
You are helpful, witty, and occasionally sarcastic but always respectful.
Keep your responses concise and conversational since they will be spoken aloud.
''';

/// Gets the JARVIS home directory (~/.jarvis).
String getJarvisHome() {
  final home =
      Platform.environment['HOME'] ??
      Platform.environment['USERPROFILE'] ??
      '.';
  return '$home/.jarvis';
}

/// Prints usage information.
void printUsage() {
  print('''
JARVIS Voice Assistant v$version

Usage: jarvis [command] [options]

Commands:
  setup               Download ML models and create default config
  version             Show version information
  (none)              Run the voice assistant

Options:
  -c, --config <path>   Path to YAML configuration file
                        (default: ~/.jarvis/config.yaml)
  -v, --verbose         Enable verbose logging (INFO level)
  -d, --debug           Enable debug logging (FINE level, includes timing)
  --trace               Enable trace logging (FINEST level, very verbose)
  -q, --quiet           Suppress all logging output
  --record              Enable session recording (saves to ./sessions/)
  --record-dir <path>   Enable recording with custom directory
  -h, --help            Show this help message

Environment Variables (alternative to config file):
  WHISPER_MODEL_PATH      Path to Whisper model file
  WHISPER_EXECUTABLE      Path to whisper-cli executable
  LLAMA_MODEL_REPO        Hugging Face model repo (e.g., ggml-org/gemma-3-1b-it-GGUF)
  LLAMA_EXECUTABLE        Path to llama-cli executable
  WAKEWORD_ENCODER_PATH   Path to wake word encoder ONNX model
  WAKEWORD_DECODER_PATH   Path to wake word decoder ONNX model
  WAKEWORD_JOINER_PATH    Path to wake word joiner ONNX model
  WAKEWORD_TOKENS_PATH    Path to wake word tokens file
  WAKEWORD_KEYWORDS_FILE  Path to wake word keywords file
  TTS_MODEL_PATH          Path to TTS model ONNX file
  TTS_TOKENS_PATH         Path to TTS tokens file
  TTS_DATA_DIR            Path to espeak-ng-data directory
  SHERPA_LIB_PATH         Path to sherpa-onnx native library
  SYSTEM_PROMPT           (Optional) Custom system prompt

Quick Start:
  # First-time setup (downloads ~150MB models)
  jarvis setup

  # Edit configuration (add whisper/llama paths)
  vim ~/.jarvis/config.yaml

  # Run
  jarvis
''');
}

/// Runs the setup command.
Future<void> runSetup(List<String> args) async {
  print('');
  print('='.padRight(50, '='));
  print('  JARVIS Setup');
  print('='.padRight(50, '='));
  print('');

  final jarvisHome = getJarvisHome();
  final modelsDir = '$jarvisHome/models';
  final configPath = '$jarvisHome/config.yaml';

  // Detect sherpa library first (needed for TTS-based acknowledgment generation)
  print('Detecting sherpa-onnx library...');
  final sherpaLib = await _detectSherpaLib();
  if (sherpaLib != null) {
    print('  Found: $sherpaLib');
  } else {
    print('  Warning: sherpa-onnx not found in pub cache');
    print('  Acknowledgment audio generation will be skipped');
  }

  // Download models
  final downloader = ModelDownloader(
    modelsDir: modelsDir,
    onProgress: (msg) => print(msg),
  );

  try {
    await downloader.downloadAll(sherpaLibPath: sherpaLib);
  } on ModelDownloadException catch (e) {
    stderr.writeln('');
    stderr.writeln('Download failed: ${e.message}');
    exit(1);
  }

  // Create default config if not exists
  if (!await File(configPath).exists()) {
    print('');
    print('Creating default configuration...');

    final modelPaths = downloader.getModelPaths();
    final assetPaths = downloader.getAssetPaths();

    // Detect executables
    print('Detecting installed tools...');
    final whisperCli = await _detectWhisperCli();
    final whisperServer = await _detectWhisperServer();
    final llamaCli = await _detectLlamaCli();

    if (whisperCli != null) print('  Found whisper-cli: $whisperCli');
    if (whisperServer != null) print('  Found whisper-server: $whisperServer (faster, keeps model warm)');
    if (llamaCli != null) print('  Found llama-cli: $llamaCli');

    final configContent =
        '''
# JARVIS Voice Assistant Configuration
# Generated by: jarvis setup

# Whisper (Speech-to-Text)
whisper_model_path: ${modelPaths['whisper_model_path']}
${whisperCli != null ? 'whisper_executable: $whisperCli' : '# whisper_executable: /path/to/whisper-cli  # Build from: https://github.com/ggerganov/whisper.cpp'}
${whisperServer != null ? 'whisper_server_executable: $whisperServer  # Faster: keeps model warm between calls' : '# whisper_server_executable: /path/to/whisper-server  # Optional: faster transcription'}

# Llama (LLM)
# Install: brew install llama.cpp OR build from source
llama_model_repo: ggml-org/gemma-3-1b-it-GGUF
${llamaCli != null ? 'llama_executable: $llamaCli' : '# llama_executable: /path/to/llama-cli  # Install: brew install llama.cpp'}

# Wake Word Detection (sherpa-onnx keyword spotter)
wakeword_encoder_path: ${modelPaths['wakeword_encoder_path']}
wakeword_decoder_path: ${modelPaths['wakeword_decoder_path']}
wakeword_joiner_path: ${modelPaths['wakeword_joiner_path']}
wakeword_tokens_path: ${modelPaths['wakeword_tokens_path']}
wakeword_keywords_file: ${modelPaths['wakeword_keywords_file']}

# TTS (Text-to-Speech)
tts_model_path: ${modelPaths['tts_model_path']}
tts_tokens_path: ${modelPaths['tts_tokens_path']}
tts_data_dir: ${modelPaths['tts_data_dir']}

# Sherpa Native Library
${sherpaLib != null ? 'sherpa_lib_path: $sherpaLib' : '# sherpa_lib_path: auto  # Auto-detect from pub cache'}

# Audio Assets
acknowledgment_dir: ${assetPaths['acknowledgment_dir']}
barge_in_dir: ${assetPaths['barge_in_dir']}

# System Prompt
system_prompt: |
  You are JARVIS, a calm, highly competent AI assistant.
  You speak in a precise, polite, British tone.
  You prioritize clarity, technical accuracy, and efficiency.
  You proactively infer intent and offer helpful next steps.
  You do not use emojis, markdown or symbols as you will be spoken out loud.
  Never include URLs, links, or web addresses in your responses - describe information verbally instead.
  You never mention that you are an AI model or LLM.
  Never say your own name "JARVIS" or similar sounding words like "Java" in responses to avoid triggering the wake word detector.
  Prefer short replies unless specifically asked for.

# Voice Activity Detection
silence_threshold: 0.01
silence_duration_ms: 20
sentence_pause_ms: 200

# Conversation History
max_history_length: 10

# Follow-up Listening
enable_follow_up: true
follow_up_timeout_ms: 4000
statement_follow_up_timeout_ms: 4000

# Barge-in (interrupt while speaking)
enable_barge_in: true
''';

    await Directory(jarvisHome).create(recursive: true);
    await File(configPath).writeAsString(configContent);
    print('Created: $configPath');

    print('');
    print('='.padRight(50, '='));
    print('  Setup Complete!');
    print('='.padRight(50, '='));
    print('');

    // Show next steps based on what was detected
    final missingTools = <String>[];
    if (whisperCli == null) missingTools.add('whisper-cli');
    if (llamaCli == null) missingTools.add('llama-cli');

    if (missingTools.isEmpty) {
      print('All tools detected! You can run JARVIS now:');
      print('');
      print('   jarvis');
      print('');
    } else {
      print('Next steps:');
      print('');
      print('1. Install missing tools: ${missingTools.join(", ")}');
      if (missingTools.contains('whisper-cli')) {
        print(
          '   - whisper-cli: Build from https://github.com/ggerganov/whisper.cpp',
        );
      }
      if (missingTools.contains('llama-cli')) {
        print('   - llama-cli: brew install llama.cpp OR build from source');
      }
      print('');
      print('2. Update config with executable paths:');
      print('   vim $configPath');
      print('');
      print('3. Run JARVIS:');
      print('   jarvis');
      print('');
    }
  } else {
    print('');
    print('Configuration already exists: $configPath');
    print('');
    print('To re-run setup, delete the config first:');
    print('   rm $configPath');
    print('   jarvis setup');
    print('');
  }
}

/// Gets the platform-specific sherpa_onnx package name prefix.
String _getSherpaPackagePrefix() {
  if (Platform.isMacOS) return 'sherpa_onnx_macos';
  if (Platform.isLinux) return 'sherpa_onnx_linux';
  if (Platform.isWindows) return 'sherpa_onnx_windows';
  // iOS and Android would use different mechanisms
  return 'sherpa_onnx';
}

/// Gets the platform-specific subdirectory name for native libs.
String _getSherpaPlatformDir() {
  if (Platform.isMacOS) return 'macos';
  if (Platform.isLinux) return 'linux';
  if (Platform.isWindows) return 'windows';
  return '';
}

/// Attempts to auto-detect sherpa-onnx library in pub cache.
Future<String?> _detectSherpaLib() async {
  final home =
      Platform.environment['HOME'] ??
      Platform.environment['USERPROFILE'] ??
      '.';

  final packagePrefix = _getSherpaPackagePrefix();
  final platformDir = _getSherpaPlatformDir();

  // Check pub cache locations
  final cacheLocations = [
    '$home/.pub-cache/hosted/pub.dev',
    '$home/.pub-cache/hosted/pub.dartlang.org',
  ];

  // Find the latest version of the platform-specific package
  String? latestPath;
  String? latestVersion;

  for (final cacheDir in cacheLocations) {
    final dir = Directory(cacheDir);
    if (!await dir.exists()) continue;

    await for (final entity in dir.list()) {
      if (entity is Directory) {
        final name = entity.path.split('/').last;
        // Match pattern like sherpa_onnx_macos-1.12.20
        if (name.startsWith('$packagePrefix-')) {
          final version = name.substring(packagePrefix.length + 1);
          // Simple version comparison (works for semantic versioning)
          if (latestVersion == null || version.compareTo(latestVersion) > 0) {
            // Check if the platform directory exists
            final libDir = Directory('${entity.path}/$platformDir');
            if (await libDir.exists()) {
              latestVersion = version;
              latestPath = libDir.path;
            }
          }
        }
      }
    }
  }

  return latestPath;
}

/// Attempts to find an executable in common locations and PATH.
Future<String?> _findExecutable(List<String> names) async {
  // Common binary locations
  final searchPaths = <String>[
    '/opt/homebrew/bin', // macOS Homebrew (ARM)
    '/usr/local/bin', // macOS Homebrew (Intel), Linux
    '/usr/bin', // Linux system
    if (Platform.isWindows) r'C:\Program Files\',
  ];

  // Add PATH directories
  final pathEnv = Platform.environment['PATH'] ?? '';
  final pathSeparator = Platform.isWindows ? ';' : ':';
  searchPaths.addAll(pathEnv.split(pathSeparator));

  // Search for each name in each path
  for (final name in names) {
    for (final dir in searchPaths) {
      if (dir.isEmpty) continue;
      final executable = Platform.isWindows ? '$name.exe' : name;
      final path = '$dir/$executable';
      if (await File(path).exists()) {
        return path;
      }
    }
  }

  return null;
}

/// Attempts to auto-detect whisper-cli executable.
Future<String?> _detectWhisperCli() async {
  // Try various names whisper might be installed as
  return _findExecutable([
    'whisper-cli', // Standard name
    'whisper', // Alternative
    'main', // Built from source (in whisper.cpp/build/bin/)
  ]);
}

/// Attempts to auto-detect whisper-server executable.
Future<String?> _detectWhisperServer() async {
  return _findExecutable([
    'whisper-server', // Standard name (Homebrew)
    'server', // Built from source (in whisper.cpp/build/bin/)
  ]);
}

/// Attempts to auto-detect llama-cli executable.
Future<String?> _detectLlamaCli() async {
  // Try various names llama might be installed as
  return _findExecutable([
    'llama-cli', // Standard name (Homebrew)
    'llama', // Alternative
    'llama-server', // Server variant
    'main', // Built from source
  ]);
}

Future<void> main(List<String> arguments) async {
  // Handle commands first
  if (arguments.isNotEmpty) {
    switch (arguments[0]) {
      case 'setup':
        await runSetup(arguments.skip(1).toList());
        return;
      case 'version':
        print('JARVIS Voice Assistant v$version');
        return;
    }
  }

  // Parse command line arguments
  String? configPath;
  var logLevel = Level.WARNING; // Default: only warnings and errors
  var recordingEnabled = false;
  String? recordDir;

  for (var i = 0; i < arguments.length; i++) {
    final arg = arguments[i];
    if (arg == '-h' || arg == '--help') {
      printUsage();
      exit(0);
    } else if (arg == '-c' || arg == '--config') {
      if (i + 1 >= arguments.length) {
        stderr.writeln('Error: --config requires a path argument');
        exit(1);
      }
      configPath = arguments[i + 1];
      i++;
    } else if (arg == '-v' || arg == '--verbose') {
      logLevel = Level.INFO;
    } else if (arg == '-d' || arg == '--debug') {
      logLevel = Level.FINE;
    } else if (arg == '--trace') {
      logLevel = Level.FINEST;
    } else if (arg == '-q' || arg == '--quiet') {
      logLevel = Level.OFF;
    } else if (arg == '--record') {
      recordingEnabled = true;
    } else if (arg == '--record-dir') {
      if (i + 1 >= arguments.length) {
        stderr.writeln('Error: --record-dir requires a path argument');
        exit(1);
      }
      recordingEnabled = true;
      recordDir = arguments[i + 1];
      i++;
    }
  }

  // Initialize logging
  LogConfig.initialize(level: logLevel);

  // Load configuration with priority:
  // 1. --config flag
  // 2. ~/.jarvis/config.yaml (if exists)
  // 3. Environment variables
  AppConfig config;
  try {
    if (configPath != null) {
      print('Loading configuration from: $configPath');
      config = await ConfigLoader.fromYamlFile(configPath);
    } else {
      // Try default config location
      final defaultConfig = '${getJarvisHome()}/config.yaml';
      if (await File(defaultConfig).exists()) {
        print('Loading configuration from: $defaultConfig');
        config = await ConfigLoader.fromYamlFile(defaultConfig);
      } else {
        print('Loading configuration from environment variables...');
        config = ConfigLoader.fromEnvironment();
      }
    }
  } on ConfigException catch (e) {
    stderr.writeln('Configuration error: ${e.message}');
    stderr.writeln('');
    stderr.writeln('Run "jarvis setup" to download models and create config.');
    stderr.writeln('Run "jarvis --help" for usage information.');
    exit(1);
  }

  // Resolve audio assets - check configured path, then ~/.jarvis/assets, then bundled
  var acknowledgmentDir = config.acknowledgmentDir;
  var bargeInDir = config.bargeInDir;

  final jarvisAssetsDir = '${getJarvisHome()}/assets';
  final jarvisAckDir = '$jarvisAssetsDir/acknowledgments';
  final jarvisBargeInDir = '$jarvisAssetsDir/bargein';

  // Resolve acknowledgment directory
  if (acknowledgmentDir != null &&
      acknowledgmentDir != 'bundled' &&
      await Directory(acknowledgmentDir).exists()) {
    // Use configured path
  } else if (await Directory(jarvisAckDir).exists()) {
    // Use generated assets from ~/.jarvis/assets
    acknowledgmentDir = jarvisAckDir;
  } else {
    // Fall back to bundled assets from package
    final bundledAck = await PackageAssets.getAcknowledgmentsDir();
    if (bundledAck != null) {
      acknowledgmentDir = bundledAck;
    } else {
      acknowledgmentDir = null;
    }
  }

  // Resolve barge-in directory
  if (bargeInDir != null &&
      bargeInDir != 'bundled' &&
      await Directory(bargeInDir).exists()) {
    // Use configured path
  } else if (await Directory(jarvisBargeInDir).exists()) {
    // Use generated assets from ~/.jarvis/assets
    bargeInDir = jarvisBargeInDir;
  } else {
    // Fall back to bundled assets from package
    final bundledBargeIn = await PackageAssets.getBargeInDir();
    if (bundledBargeIn != null) {
      bargeInDir = bundledBargeIn;
    } else {
      bargeInDir = null;
    }
  }

  // CLI args override config file values for recording
  final effectiveRecordingEnabled = recordingEnabled || config.recordingEnabled;
  final effectiveSessionDir = recordDir ?? config.sessionDir;

  // Apply default system prompt if not set
  final assistantConfig = VoiceAssistantConfig(
    whisperModelPath: config.whisperModelPath,
    whisperExecutablePath: config.whisperExecutablePath,
    llamaModelRepo: config.llamaModelRepo,
    llamaExecutablePath: config.llamaExecutablePath,
    wakeWordEncoderPath: config.wakeWordEncoderPath,
    wakeWordDecoderPath: config.wakeWordDecoderPath,
    wakeWordJoinerPath: config.wakeWordJoinerPath,
    wakeWordTokensPath: config.wakeWordTokensPath,
    wakeWordKeywordsFile: config.wakeWordKeywordsFile,
    ttsModelPath: config.ttsModelPath,
    ttsTokensPath: config.ttsTokensPath,
    ttsDataDir: config.ttsDataDir,
    sherpaLibPath: config.sherpaLibPath,
    acknowledgmentDir: acknowledgmentDir,
    systemPrompt: config.systemPrompt ?? defaultSystemPrompt,
    silenceThreshold: config.silenceThreshold,
    silenceDuration: config.silenceDuration,
    maxHistoryLength: config.maxHistoryLength,
    sentencePause: config.sentencePause,
    enableFollowUp: config.enableFollowUp,
    followUpTimeout: config.followUpTimeout,
    statementFollowUpTimeout: config.statementFollowUpTimeout,
    enableBargeIn: config.enableBargeIn,
    bargeInDir: bargeInDir,
    audioPlayer: config.audioPlayer,
    audioPlayerPath: config.audioPlayerPath,
    recordingEnabled: effectiveRecordingEnabled,
    sessionDir: effectiveSessionDir,
  );

  // Create voice assistant
  final assistant = VoiceAssistant(config: assistantConfig);

  // Set up graceful shutdown
  var shutdownRequested = false;
  final shutdownCompleter = Completer<void>();

  Future<void> shutdown() async {
    if (shutdownRequested) return;
    shutdownRequested = true;

    print('');
    print('Shutting down JARVIS...');

    try {
      await assistant.stop();
      await assistant.dispose();
      print('Goodbye!');
    } catch (e) {
      stderr.writeln('Error during shutdown: $e');
    }

    shutdownCompleter.complete();
  }

  // Handle SIGINT (Ctrl+C) and SIGTERM
  ProcessSignal.sigint.watch().listen((_) => shutdown());
  if (!Platform.isWindows) {
    ProcessSignal.sigterm.watch().listen((_) => shutdown());
  }

  // Subscribe to state changes
  assistant.stateStream.listen((state) {
    switch (state) {
      case AssistantState.idle:
        print('[State] Idle');
      case AssistantState.listeningForWakeWord:
        print('[State] Listening for wake word...');
      case AssistantState.listening:
        print('[State] Listening to you...');
      case AssistantState.processing:
        print('[State] Processing...');
      case AssistantState.speaking:
        print('[State] Speaking...');
      case AssistantState.awaitingFollowUp:
        print('[State] Awaiting your response...');
      case AssistantState.prompting:
        print('[State] Prompting...');
      case AssistantState.error:
        print('[State] Error occurred, recovering...');
    }
  });

  // Subscribe to transcriptions
  assistant.transcriptionStream.listen((transcription) {
    print('[You] $transcription');
  });

  // Subscribe to responses
  assistant.responseStream.listen((response) {
    print('[JARVIS] $response');
  });

  // Initialize and start
  try {
    print('');
    print('='.padRight(50, '='));
    print('  JARVIS Voice Assistant v$version');
    print('='.padRight(50, '='));
    print('');
    print('Initializing...');

    await assistant.initialize();
    print('Initialization complete.');
    print('');
    print('Say the wake word to start a conversation.');
    print('Press Ctrl+C to exit.');
    print('');

    await assistant.start();

    // Wait for shutdown signal
    await shutdownCompleter.future;
    exit(0);
  } on VoiceAssistantException catch (e) {
    stderr.writeln('');
    stderr.writeln('Failed to start JARVIS: ${e.message}');
    if (e.cause != null) {
      stderr.writeln('Cause: ${e.cause}');
    }
    stderr.writeln('');
    stderr.writeln('Please check your configuration and try again.');
    await assistant.dispose();
    exit(1);
  } catch (e, stackTrace) {
    stderr.writeln('');
    stderr.writeln('Unexpected error: $e');
    stderr.writeln(stackTrace);
    await assistant.dispose();
    exit(1);
  }
}
